import { MethodParser } from '../../parsers/MethodParser';
import { ApiMethodsFile } from '../../interfaces/ApiMethodsFile';
import { ApiMethod } from '../../interfaces/ApiMethod';

describe('Create App Method Parameters', () => {
  test('should parse all form data parameters for POST /api/v1/apps', () => {
    const methodParser = new MethodParser();
    const methodFiles = methodParser.parseAllMethods();

    // Find the apps method file
    const appsMethodFile = methodFiles.find((file: ApiMethodsFile) =>
      file.name.toLowerCase().includes('apps')
    );

    expect(appsMethodFile).toBeDefined();

    // Find the create method
    const createMethod = appsMethodFile!.methods.find(
      (method: ApiMethod) =>
        method.name.toLowerCase().includes('create') &&
        method.endpoint.includes('/api/v1/apps')
    );

    expect(createMethod).toBeDefined();
    expect(createMethod!.httpMethod).toBe('POST');
    expect(createMethod!.endpoint).toBe('/api/v1/apps');

    // Verify all 4 form data parameters are present
    expect(createMethod!.parameters).toBeDefined();
    expect(createMethod!.parameters).toHaveLength(4);

    const paramNames = createMethod!.parameters!.map((p) => p.name);
    expect(paramNames).toContain('client_name');
    expect(paramNames).toContain('redirect_uris');
    expect(paramNames).toContain('scopes');
    expect(paramNames).toContain('website');

    // Verify required parameters
    const clientName = createMethod!.parameters!.find(
      (p) => p.name === 'client_name'
    );
    const redirectUris = createMethod!.parameters!.find(
      (p) => p.name === 'redirect_uris'
    );
    const scopes = createMethod!.parameters!.find((p) => p.name === 'scopes');
    const website = createMethod!.parameters!.find((p) => p.name === 'website');

    expect(clientName!.required).toBe(true);
    expect(redirectUris!.required).toBe(true);
    expect(scopes!.required).toBeUndefined(); // Optional
    expect(website!.required).toBeUndefined(); // Optional

    // Verify scopes parameter has OAuth enum values
    expect(scopes!.schema?.enum).toBeDefined();
    expect(scopes!.schema!.enum!.length).toBeGreaterThan(40);
    expect(scopes!.schema!.enum).toContain('read');
    expect(scopes!.schema!.enum).toContain('write');
    expect(scopes!.schema!.enum).toContain('profile');
    expect(scopes!.schema!.enum).toContain('admin:read');
  });

  test('should generate oneOf schema for redirect_uris parameter in TypeParser', () => {
    // Import required types and utilities
    const { TypeParser } = require('../../generators/TypeParser');
    const { UtilityHelpers } = require('../../generators/UtilityHelpers');
    const { MethodParser } = require('../../parsers/MethodParser');

    const methodParser = new MethodParser();
    const methodFiles = methodParser.parseAllMethods();

    // Find the apps method file
    const appsMethodFile = methodFiles.find((file: any) =>
      file.name.toLowerCase().includes('apps')
    );

    expect(appsMethodFile).toBeDefined();

    // Find the create method
    const createMethod = appsMethodFile!.methods.find(
      (method: any) =>
        method.name.toLowerCase().includes('create') &&
        method.endpoint.includes('/api/v1/apps')
    );

    expect(createMethod).toBeDefined();

    // Find the redirect_uris parameter
    const redirectUrisParam = createMethod!.parameters.find(
      (p: any) => p.name === 'redirect_uris'
    );

    expect(redirectUrisParam).toBeDefined();
    expect(redirectUrisParam!.description).toContain(
      'String or Array of Strings'
    );

    // Convert parameter to schema using TypeParser
    // Note: This tests the TypeParser in isolation, not the final OpenAPI schema
    // which gets overridden in MethodConverter for the createApp operation
    const utilityHelpers = new UtilityHelpers();
    const typeParser = new TypeParser(utilityHelpers);
    const schema = typeParser.convertParameterToSchema(redirectUrisParam);

    // Verify oneOf schema is generated by TypeParser
    expect(schema.oneOf).toBeDefined();
    expect(schema.oneOf).toHaveLength(2);

    // Verify first option: string with uri format
    expect(schema.oneOf[0]).toEqual({
      type: 'string',
      format: 'uri',
    });

    // Verify second option: array of strings with uri format
    expect(schema.oneOf[1]).toEqual({
      type: 'array',
      items: {
        type: 'string',
        format: 'uri',
      },
    });

    // Verify description is preserved
    expect(schema.description).toBe(redirectUrisParam.description);
  });
});
